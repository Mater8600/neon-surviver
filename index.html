<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Pong 2-Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #111;
            color: white;
            overflow: hidden; /* Prevent scrolling */
            touch-action: none;
        }

        #gameCanvas {
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
            border: 4px solid #333;
            background-color: #000;
        }

        .crt-line {
            width: 100%;
            height: 2px;
            background: rgba(255, 255, 255, 0.1);
            position: absolute;
            animation: scanline 5s linear infinite;
            pointer-events: none;
            z-index: 10;
        }

        @keyframes scanline {
            0% { top: 0%; }
            100% { top: 100%; }
        }

        /* Controls hint overlay */
        .controls-hint {
            color: #888;
            font-size: 0.8rem;
            margin-top: 1rem;
            text-align: center;
        }
        
        .key {
            display: inline-block;
            padding: 4px 8px;
            border: 1px solid #555;
            border-radius: 4px;
            background: #222;
            color: #fff;
            margin: 0 2px;
            font-family: sans-serif;
            font-weight: bold;
            font-size: 0.7rem;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen">

    <!-- Scanline effect for retro feel -->
    <div class="crt-line"></div>

    <div class="relative">
        <!-- Score Board -->
        <div class="absolute top-4 w-full flex justify-between px-16 text-4xl font-bold select-none pointer-events-none opacity-80 z-10">
            <div id="score1" class="text-green-500">0</div>
            <div id="score2" class="text-blue-500">0</div>
        </div>
        
        <!-- Game Canvas -->
        <canvas id="gameCanvas"></canvas>

        <!-- Start Overlay -->
        <div id="startScreen" class="absolute inset-0 flex flex-col items-center justify-center bg-black/80 z-20">
            <h1 class="text-4xl mb-4 text-white tracking-widest text-center">PONG</h1>
            <p class="text-sm text-gray-400 mb-8 text-center max-w-md leading-6 px-4">
                Classic 1v1
            </p>
            <button id="startBtn" class="px-8 py-4 bg-white text-black font-bold hover:bg-gray-200 transition active:scale-95 text-xs sm:text-sm">
                START GAME
            </button>
        </div>
    </div>

    <!-- Controls Info -->
    <div class="controls-hint flex gap-8">
        <div>
            <span class="text-green-500 block mb-2">PLAYER 1</span>
            <span class="key">W</span> <span class="key">S</span>
        </div>
        <div>
            <span class="text-blue-500 block mb-2">PLAYER 2</span>
            <span class="key">↑</span> <span class="key">↓</span>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const score1El = document.getElementById('score1');
        const score2El = document.getElementById('score2');
        const startScreen = document.getElementById('startScreen');
        const startBtn = document.getElementById('startBtn');

        // Game Configuration
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 500;
        const PADDLE_WIDTH = 15;
        const PADDLE_HEIGHT = 80;
        const BALL_SIZE = 12;
        const INITIAL_BALL_SPEED = 7;
        const PADDLE_SPEED = 8;
        
        // Dynamic scaling
        function resizeCanvas() {
            // Max width is 800, but scale down for smaller screens
            const maxWidth = Math.min(window.innerWidth - 20, 800);
            const scale = maxWidth / CANVAS_WIDTH;
            
            canvas.style.width = `${maxWidth}px`;
            canvas.style.height = `${CANVAS_HEIGHT * scale}px`;
        }
        
        // Set actual canvas resolution
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Game State
        let gameRunning = false;
        let animationId;

        const player1 = {
            x: 20,
            y: CANVAS_HEIGHT / 2 - PADDLE_HEIGHT / 2,
            score: 0,
            color: '#4ade80' // Green-400
        };

        const player2 = {
            x: CANVAS_WIDTH - 20 - PADDLE_WIDTH,
            y: CANVAS_HEIGHT / 2 - PADDLE_HEIGHT / 2,
            score: 0,
            color: '#60a5fa' // Blue-400
        };

        const ball = {
            x: CANVAS_WIDTH / 2,
            y: CANVAS_HEIGHT / 2,
            dx: 0,
            dy: 0,
            speed: INITIAL_BALL_SPEED
        };

        // Input State
        const keys = {
            w: false,
            s: false,
            ArrowUp: false,
            ArrowDown: false
        };

        // Event Listeners
        window.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = true;
            }
        });

        window.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = false;
            }
        });

        startBtn.addEventListener('click', () => {
            startScreen.style.display = 'none';
            resetBall();
            gameRunning = true;
            player1.score = 0;
            player2.score = 0;
            updateScoreDisplay();
            animate();
        });

        function resetBall() {
            ball.x = CANVAS_WIDTH / 2 - BALL_SIZE / 2;
            ball.y = CANVAS_HEIGHT / 2 - BALL_SIZE / 2;
            ball.speed = INITIAL_BALL_SPEED;
            
            // Randomize start direction
            const directionX = Math.random() > 0.5 ? 1 : -1;
            const directionY = Math.random() > 0.5 ? 1 : -1;
            
            ball.dx = directionX * ball.speed;
            ball.dy = directionY * (ball.speed * 0.6); // Start with slightly less vertical speed
        }

        function updateScoreDisplay() {
            score1El.innerText = player1.score;
            score2El.innerText = player2.score;
        }

        function drawNet() {
            ctx.fillStyle = '#333';
            const netWidth = 4;
            const gap = 15;
            for (let i = 0; i < CANVAS_HEIGHT; i += gap * 2) {
                ctx.fillRect(CANVAS_WIDTH / 2 - netWidth / 2, i, netWidth, gap);
            }
        }

        function drawRect(x, y, w, h, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x, y, w, h);
            
            // Inner glow effect
            ctx.shadowColor = color;
            ctx.shadowBlur = 10;
            ctx.fillRect(x, y, w, h);
            ctx.shadowBlur = 0; // Reset
        }

        function movePaddles() {
            // Player 1 (W/S)
            if (keys.w && player1.y > 0) {
                player1.y -= PADDLE_SPEED;
            }
            if (keys.s && player1.y < CANVAS_HEIGHT - PADDLE_HEIGHT) {
                player1.y += PADDLE_SPEED;
            }

            // Player 2 (Arrows)
            if (keys.ArrowUp && player2.y > 0) {
                player2.y -= PADDLE_SPEED;
            }
            if (keys.ArrowDown && player2.y < CANVAS_HEIGHT - PADDLE_HEIGHT) {
                player2.y += PADDLE_SPEED;
            }
        }

        function moveBall() {
            ball.x += ball.dx;
            ball.y += ball.dy;

            // Wall Collision (Top/Bottom)
            if (ball.y <= 0 || ball.y + BALL_SIZE >= CANVAS_HEIGHT) {
                ball.dy *= -1;
                // Add a small satisfying "pop" visual or sound effect trigger here in a full engine
            }

            // Paddle Collision Logic
            // Player 1
            if (
                ball.x <= player1.x + PADDLE_WIDTH &&
                ball.x + BALL_SIZE >= player1.x &&
                ball.y + BALL_SIZE >= player1.y &&
                ball.y <= player1.y + PADDLE_HEIGHT
            ) {
                handlePaddleHit(player1);
            }

            // Player 2
            if (
                ball.x + BALL_SIZE >= player2.x &&
                ball.x <= player2.x + PADDLE_WIDTH &&
                ball.y + BALL_SIZE >= player2.y &&
                ball.y <= player2.y + PADDLE_HEIGHT
            ) {
                handlePaddleHit(player2);
            }

            // Scoring
            if (ball.x < 0) {
                player2.score++;
                updateScoreDisplay();
                resetBall();
            } else if (ball.x > CANVAS_WIDTH) {
                player1.score++;
                updateScoreDisplay();
                resetBall();
            }
        }

        function handlePaddleHit(paddle) {
            // Reverse X direction
            // We force the ball direction based on which paddle hit it to prevent sticking
            ball.dx = paddle === player1 ? Math.abs(ball.dx) : -Math.abs(ball.dx);

            // Increase speed slightly
            ball.speed += 0.5;
            
            // Recalculate velocity vector based on hit position relative to paddle center
            // This allows players to "aim" by hitting the edges of the paddle
            const paddleCenter = paddle.y + PADDLE_HEIGHT / 2;
            const ballCenter = ball.y + BALL_SIZE / 2;
            const relativeIntersectY = paddleCenter - ballCenter;
            
            // Normalize intersection (0 to 1)
            const normalizedIntersect = relativeIntersectY / (PADDLE_HEIGHT / 2);
            const bounceAngle = normalizedIntersect * (Math.PI / 4); // Max 45 degree angle

            const directionX = ball.dx > 0 ? 1 : -1;
            
            ball.dx = directionX * ball.speed * Math.cos(bounceAngle);
            ball.dy = ball.speed * -Math.sin(bounceAngle);
        }

        function draw() {
            // Clear screen
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            drawNet();
            drawRect(player1.x, player1.y, PADDLE_WIDTH, PADDLE_HEIGHT, player1.color);
            drawRect(player2.x, player2.y, PADDLE_WIDTH, PADDLE_HEIGHT, player2.color);
            
            // Ball (White)
            drawRect(ball.x, ball.y, BALL_SIZE, BALL_SIZE, '#ffffff');
        }

        function animate() {
            if (!gameRunning) return;

            movePaddles();
            moveBall();
            draw();

            animationId = requestAnimationFrame(animate);
        }

        // Initial Draw
        draw();

    </script>
</body>
</html>

